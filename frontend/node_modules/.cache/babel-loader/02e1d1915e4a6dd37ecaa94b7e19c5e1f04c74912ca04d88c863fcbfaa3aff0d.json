{"ast":null,"code":"// Algorithm descriptions and pseudocode (kept from your previous data)\nexport const ALGO_INFO = {\n  bubbleSort: {\n    key: \"bubbleSort\",\n    title: \"Bubble Sort\",\n    description: \"Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. Repeats until sorted.\",\n    pseudoCode: `for i from 0 to n-1:\n  for j from 0 to n-i-2:\n    if arr[j] > arr[j+1]:\n      swap(arr[j], arr[j+1])`,\n    complexity: {\n      time: \"O(n²)\",\n      space: \"O(1)\"\n    }\n  },\n  selectionSort: {\n    key: \"selectionSort\",\n    title: \"Selection Sort\",\n    description: \"Selection Sort finds the minimum element from unsorted part and places it at the beginning. Repeats for each position.\",\n    pseudoCode: `for i from 0 to n-1:\n  min_idx = i\n  for j from i+1 to n-1:\n    if arr[j] < arr[min_idx]:\n      min_idx = j\n  swap(arr[i], arr[min_idx])`,\n    complexity: {\n      time: \"O(n²)\",\n      space: \"O(1)\"\n    }\n  },\n  insertionSort: {\n    key: \"insertionSort\",\n    title: \"Insertion Sort\",\n    description: \"Insertion Sort builds the sorted array one item at a time by inserting elements into their correct position in the sorted part.\",\n    pseudoCode: `for i from 1 to n-1:\n  key = arr[i]\n  j = i - 1\n  while j >= 0 and arr[j] > key:\n    arr[j+1] = arr[j]\n    j = j - 1\n  arr[j+1] = key`,\n    complexity: {\n      time: \"O(n²) (Best: O(n))\",\n      space: \"O(1)\"\n    }\n  },\n  mergeSort: {\n    key: \"mergeSort\",\n    title: \"Merge Sort\",\n    description: \"Merge Sort divides the array in halves, recursively sorts each half, and then merges them back together.\",\n    pseudoCode: `mergeSort(arr, l, r):\n  if l < r:\n    m = (l + r) // 2\n    mergeSort(arr, l, m)\n    mergeSort(arr, m + 1, r)\n    merge(arr, l, m, r)`,\n    complexity: {\n      time: \"O(n log n)\",\n      space: \"O(n)\"\n    }\n  },\n  quickSort: {\n    key: \"quickSort\",\n    title: \"Quick Sort\",\n    description: \"Quick Sort picks a pivot, partitions the array around the pivot, and recursively sorts the partitions.\",\n    pseudoCode: `quickSort(arr, low, high):\n  if low < high:\n    pi = partition(arr, low, high)\n    quickSort(arr, low, pi - 1)\n    quickSort(arr, pi + 1, high)`,\n    complexity: {\n      time: \"O(n log n) (avg)\",\n      space: \"O(log n)\"\n    }\n  }\n};","map":{"version":3,"names":["ALGO_INFO","bubbleSort","key","title","description","pseudoCode","complexity","time","space","selectionSort","insertionSort","mergeSort","quickSort"],"sources":["D:/dsa_visual/frontend/src/data/algorithmInfo.js"],"sourcesContent":["// Algorithm descriptions and pseudocode (kept from your previous data)\r\nexport const ALGO_INFO = {\r\n  bubbleSort: {\r\n    key: \"bubbleSort\",\r\n    title: \"Bubble Sort\",\r\n    description:\r\n      \"Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. Repeats until sorted.\",\r\n    pseudoCode: `for i from 0 to n-1:\r\n  for j from 0 to n-i-2:\r\n    if arr[j] > arr[j+1]:\r\n      swap(arr[j], arr[j+1])`,\r\n    complexity: { time: \"O(n²)\", space: \"O(1)\" },\r\n  },\r\n  selectionSort: {\r\n    key: \"selectionSort\",\r\n    title: \"Selection Sort\",\r\n    description:\r\n      \"Selection Sort finds the minimum element from unsorted part and places it at the beginning. Repeats for each position.\",\r\n    pseudoCode: `for i from 0 to n-1:\r\n  min_idx = i\r\n  for j from i+1 to n-1:\r\n    if arr[j] < arr[min_idx]:\r\n      min_idx = j\r\n  swap(arr[i], arr[min_idx])`,\r\n    complexity: { time: \"O(n²)\", space: \"O(1)\" },\r\n  },\r\n  insertionSort: {\r\n    key: \"insertionSort\",\r\n    title: \"Insertion Sort\",\r\n    description:\r\n      \"Insertion Sort builds the sorted array one item at a time by inserting elements into their correct position in the sorted part.\",\r\n    pseudoCode: `for i from 1 to n-1:\r\n  key = arr[i]\r\n  j = i - 1\r\n  while j >= 0 and arr[j] > key:\r\n    arr[j+1] = arr[j]\r\n    j = j - 1\r\n  arr[j+1] = key`,\r\n    complexity: { time: \"O(n²) (Best: O(n))\", space: \"O(1)\" },\r\n  },\r\n  mergeSort: {\r\n    key: \"mergeSort\",\r\n    title: \"Merge Sort\",\r\n    description:\r\n      \"Merge Sort divides the array in halves, recursively sorts each half, and then merges them back together.\",\r\n    pseudoCode: `mergeSort(arr, l, r):\r\n  if l < r:\r\n    m = (l + r) // 2\r\n    mergeSort(arr, l, m)\r\n    mergeSort(arr, m + 1, r)\r\n    merge(arr, l, m, r)`,\r\n    complexity: { time: \"O(n log n)\", space: \"O(n)\" },\r\n  },\r\n  quickSort: {\r\n    key: \"quickSort\",\r\n    title: \"Quick Sort\",\r\n    description:\r\n      \"Quick Sort picks a pivot, partitions the array around the pivot, and recursively sorts the partitions.\",\r\n    pseudoCode: `quickSort(arr, low, high):\r\n  if low < high:\r\n    pi = partition(arr, low, high)\r\n    quickSort(arr, low, pi - 1)\r\n    quickSort(arr, pi + 1, high)`,\r\n    complexity: { time: \"O(n log n) (avg)\", space: \"O(log n)\" },\r\n  },\r\n};\r\n"],"mappings":"AAAA;AACA,OAAO,MAAMA,SAAS,GAAG;EACvBC,UAAU,EAAE;IACVC,GAAG,EAAE,YAAY;IACjBC,KAAK,EAAE,aAAa;IACpBC,WAAW,EACT,gJAAgJ;IAClJC,UAAU,EAAE;AAChB;AACA;AACA,6BAA6B;IACzBC,UAAU,EAAE;MAAEC,IAAI,EAAE,OAAO;MAAEC,KAAK,EAAE;IAAO;EAC7C,CAAC;EACDC,aAAa,EAAE;IACbP,GAAG,EAAE,eAAe;IACpBC,KAAK,EAAE,gBAAgB;IACvBC,WAAW,EACT,wHAAwH;IAC1HC,UAAU,EAAE;AAChB;AACA;AACA;AACA;AACA,6BAA6B;IACzBC,UAAU,EAAE;MAAEC,IAAI,EAAE,OAAO;MAAEC,KAAK,EAAE;IAAO;EAC7C,CAAC;EACDE,aAAa,EAAE;IACbR,GAAG,EAAE,eAAe;IACpBC,KAAK,EAAE,gBAAgB;IACvBC,WAAW,EACT,iIAAiI;IACnIC,UAAU,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB;IACbC,UAAU,EAAE;MAAEC,IAAI,EAAE,oBAAoB;MAAEC,KAAK,EAAE;IAAO;EAC1D,CAAC;EACDG,SAAS,EAAE;IACTT,GAAG,EAAE,WAAW;IAChBC,KAAK,EAAE,YAAY;IACnBC,WAAW,EACT,0GAA0G;IAC5GC,UAAU,EAAE;AAChB;AACA;AACA;AACA;AACA,wBAAwB;IACpBC,UAAU,EAAE;MAAEC,IAAI,EAAE,YAAY;MAAEC,KAAK,EAAE;IAAO;EAClD,CAAC;EACDI,SAAS,EAAE;IACTV,GAAG,EAAE,WAAW;IAChBC,KAAK,EAAE,YAAY;IACnBC,WAAW,EACT,wGAAwG;IAC1GC,UAAU,EAAE;AAChB;AACA;AACA;AACA,iCAAiC;IAC7BC,UAAU,EAAE;MAAEC,IAAI,EAAE,kBAAkB;MAAEC,KAAK,EAAE;IAAW;EAC5D;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}